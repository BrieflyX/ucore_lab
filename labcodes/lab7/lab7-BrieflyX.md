# Lab7 Report
# 裴中煜 2012010685

## 练习1

### 内核级信号量的设计描述

首先是等待队列的实现，在wait.c/wait.h中实现了一个新的队列结构即睡眠状态的进程的等待队列，队列中的进程都进入了SLEEPING状态，这个结构用于维护等待同一个信号量的进程信息。

然后即是信号量sem.c/sem.h中给出了实现，semaphore_t的结构比较简单
```
typedef struct {
    int value;
    wait_queue_t wait_queue;
} semaphore_t;
```
其中value即能够同时进入临界区的进程数目，而wait_queue则是在临界区外等待的进程队列。

信号量结构提供的接口为进入临界区的down()函数与离开临界区的up()函数。down函数在执行时首先关闭中断，然后检查value的值是否大于0，如果大于0则进程可以进入临界区，直接返回。如果value的值为0则进程就需要等待，调用wait_current_set函数将当前进程设置为SLEEPING状态并加入wait_queue，之后就可以调用schedule函数重新对进程进行调度。

而up函数相对简单，检查一下wait_queue中是否还有进程等待，如果有则调用wakeup_wait函数，这个函数会进一步调用wakeup_proc函数唤醒队列中的第一个进程继续执行，这表示进程可以进入临界区了。如果没有进程在等待，则将value值加1。

对wait_queue与value操作时都需要关闭中断以保证up与down操作都是原子的不会被打断。

大致的执行流程为：调用down函数-->wait_current_set进入等待队列-->PROC_SLEEPING睡眠-->其他进程调用up函数-->wakeup_proc被唤醒-->进入临界区执行-->调用up函数-->其他进程进入临界区或者value++。

### 用户态进程/线程信号量机制

用户态进程/线程的的信号量机制主要用于用户态进程自己进行同步互斥操作，需要在libs库中提供相应的编程接口。原理上与内核级信号量并无本质区别，只是对用户的接口需要进行进一步的封装，在内核级信号量的基础上，将接口开放给用户，仍然还是需要保证内部的操作都是原子的。

与内核级信号量的相同点是都为了实现同步互斥机制，不同点在于内核中实现同步互斥是为了底层资源的共享与保护，而用户态则是用户自己的资源共享与保护。

## 练习2