# Lab7 Report
# 裴中煜 2012010685

## 练习1

### 内核级信号量的设计描述

首先是等待队列的实现，在wait.c/wait.h中实现了一个新的队列结构即睡眠状态的进程的等待队列，队列中的进程都进入了SLEEPING状态，这个结构用于维护等待同一个信号量的进程信息。

然后即是信号量sem.c/sem.h中给出了实现，semaphore_t的结构比较简单
```
typedef struct {
    int value;
    wait_queue_t wait_queue;
} semaphore_t;
```
其中value即能够同时进入临界区的进程数目，而wait_queue则是在临界区外等待的进程队列。

信号量结构提供的接口为进入临界区的down()函数与离开临界区的up()函数。down函数在执行时首先关闭中断，然后检查value的值是否大于0，如果大于0则进程可以进入临界区，直接返回。如果value的值为0则进程就需要等待，调用wait_current_set函数将当前进程设置为SLEEPING状态并加入wait_queue，之后就可以调用schedule函数重新对进程进行调度。

而up函数相对简单，检查一下wait_queue中是否还有进程等待，如果有则调用wakeup_wait函数，这个函数会进一步调用wakeup_proc函数唤醒队列中的第一个进程继续执行，这表示进程可以进入临界区了。如果没有进程在等待，则将value值加1。

对wait_queue与value操作时都需要关闭中断以保证up与down操作都是原子的不会被打断。

大致的执行流程为：调用down函数-->wait_current_set进入等待队列-->PROC_SLEEPING睡眠-->其他进程调用up函数-->wakeup_proc被唤醒-->进入临界区执行-->调用up函数-->其他进程进入临界区或者value++。

### 用户态进程/线程信号量机制

用户态进程/线程的的信号量机制主要用于用户态进程自己进行同步互斥操作，需要在libs库中提供相应的编程接口。原理上与内核级信号量并无本质区别，只是对用户的接口需要进行进一步的封装，在内核级信号量的基础上，将接口开放给用户，仍然还是需要保证内部的操作都是原子的。

与内核级信号量的相同点是都为了实现同步互斥机制，不同点在于内核中实现同步互斥是为了底层资源的共享与保护，而用户态则是用户自己的资源共享与保护。

## 练习2

### 内核级条件变量的设计

内核级条件变量是依靠信号量机制来实现的，在monitor.h中定义了条件变量结构condvar_t与管程结构monitor_t。其中条件变量提供了2个操作cond_wait与cond_signal，分别用于进程挂起（希望进入临界区，阻塞）与进程发出信号（自己退出临界区）。

cond_wait的实现逻辑为
```
cv.count ++;
if(mt.next_count>0)
   signal(mt.next)
else
   signal(mt.mutex);
wait(cv.sem);
cv.count --;
```
对于每个管程，都提供有一个信号量mutex，进程在进入管程之前必须执行wait(mutex)，离开管程之后必须执行signal(mutex)。因为信号进程必须等待直到重新启动进程或者离开或者等待，故引入了一个信号量next以供信号进程挂起自己，而且还有一个整型变量next_count记录挂起在next上的进程数量。
所以在cond_wait实现中，先检查是否有进程挂起在next上，如果是就signal(next)，否则就signal(mt.mutex)。接着等待条件变量自己的sem信号量，当信号量不为0时就可以进入临界区了。

cond_signal的实现逻辑为
```
if(cv.count>0) {
    mt.next_count ++;
    signal(cv.sem);
    wait(mt.next);
    mt.next_count--;
}
```
进程将离开管程，此时将next_count加1，随后释放cv.sem信号量，接着它会等待下一个next信号以便再次进入管程。

### 用户态进程/线程条件变量机制

实现与内核态的条件变量机制相同，将对应的接口开放给用户即可，让用户自己编程来协调自己不同进程/线程的共享访问操作。其余内核态条件变量的区别同用户态/内核态的信号量的区别。

## 与参考答案的区别

本次实验编码量不大，而且在需要实现的地方逻辑已经说明的非常清楚（甚至给出了伪码），故与参考答案并没有多少不同点。

## 实验中的知识点

实验中重要的知识点即是管程和信号量的实现，通过哲学家就餐问题的实现能够发现二者在对进程同步互斥处理上的不同点。而这两者能够保证正确性的基础就是能够实现原子操作，这在前几次实验中已经开始使用local_intr_save/local_intr_restore宏了，但lab7中这两个宏的作用尤为明显。

## 原理课中的知识点

原理课中有叙述在管程的实现中，如果一个进程执行了signal操作，接下来是否进行切换有2种方法（Hoare与Hansen）。而这在实验中并没有体现出来，也没有进行比较。